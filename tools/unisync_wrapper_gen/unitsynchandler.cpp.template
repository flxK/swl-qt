#include "unitsynchandler.h"
#if defined Q_OS_LINUX || defined Q_OS_MAC
    #include <dlfcn.h>
#elif defined Q_OS_WIN32
    #error "Not implemented yet."
#else
    #error "Unknown target OS."
#endif

UnitsyncHandler::UnitsyncHandler(QObject* parent, Logger& logger, std::string path) :
        QObject(parent), logger(logger), ready(false), handle(NULL) {
    logger.info("Loading unitsync at ", path);
    #if defined Q_OS_LINUX || defined Q_OS_MAC
        handle = dlopen(path.c_str(), RTLD_LAZY | RTLD_LOCAL);
        if(handle == NULL) {
            logger.error("Could not load unitsync at ", path, ": ", dlerror());
            return;
        }

        ${fptr_initialization_unix}

        ready = true;
    #elif defined Q_OS_WIN32
        #error "Not implemented yet."
    #else
        #error "Unknown target OS."
    #endif
}

UnitsyncHandler::~UnitsyncHandler() {
    #if defined Q_OS_LINUX || defined Q_OS_MAC
        if (handle)
            dlclose(handle);
    #elif defined Q_OS_WIN32
        #error "Not implemented yet."
    #else
        #error "Unknown target OS."
    #endif
}

UnitsyncHandler::UnitsyncHandler(UnitsyncHandler&& h) : QObject(h.parent()),
        logger(h.logger), ready(h.ready), handle(h.handle) {

    h.handle = NULL; // Quite an important line, if you ask me.

    ${move_ctor_assignment}
}

// Returns a %-escaped string ready for use in a data URL.
QString UnitsyncHandler::jsReadFileVFS(int fd, int size) {
    char buf[size + sizeof(int)];
    if (fptr_ReadFileVFS(fd, (unsigned char*)buf, size) != size)
        logger.warning("ReadFileVFS(): size mismatch");
    QString res, tmp;
    for (int i = 0; i < size; i++) {
        // %X converts an unsigned int into hex representation and we take the
	// last 2 characters to get the byte value.
        tmp = tmp.sprintf("%X", buf[i]).right(2);
	if (tmp.length() == 1)
            tmp = "0" + tmp;
	res += "%" + tmp;
    }
    return res;
}

${public_methods_definitions}
